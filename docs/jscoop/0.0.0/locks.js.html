<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>locks.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Condition.html">Condition</a><ul class='methods'><li data-type='method'><a href="Condition.html#acquire">acquire</a></li><li data-type='method'><a href="Condition.html#locked">locked</a></li><li data-type='method'><a href="Condition.html#notify">notify</a></li><li data-type='method'><a href="Condition.html#notifyAll">notifyAll</a></li><li data-type='method'><a href="Condition.html#release">release</a></li><li data-type='method'><a href="Condition.html#wait">wait</a></li></ul></li><li><a href="Event.html">Event</a><ul class='methods'><li data-type='method'><a href="Event.html#clear">clear</a></li><li data-type='method'><a href="Event.html#isSet">isSet</a></li><li data-type='method'><a href="Event.html#set">set</a></li><li data-type='method'><a href="Event.html#wait">wait</a></li></ul></li><li><a href="Future.html">Future</a><ul class='methods'><li data-type='method'><a href="Future.html#done">done</a></li><li data-type='method'><a href="Future.html#error">error</a></li><li data-type='method'><a href="Future.html#result">result</a></li><li data-type='method'><a href="Future.html#setError">setError</a></li><li data-type='method'><a href="Future.html#setResult">setResult</a></li></ul></li><li><a href="LifoQueue.html">LifoQueue</a><ul class='methods'><li data-type='method'><a href="LifoQueue.html#_get">_get</a></li><li data-type='method'><a href="LifoQueue.html#_put">_put</a></li><li data-type='method'><a href="LifoQueue.html#empty">empty</a></li><li data-type='method'><a href="LifoQueue.html#full">full</a></li><li data-type='method'><a href="LifoQueue.html#get">get</a></li><li data-type='method'><a href="LifoQueue.html#getNoWait">getNoWait</a></li><li data-type='method'><a href="LifoQueue.html#join">join</a></li><li data-type='method'><a href="LifoQueue.html#maxsize">maxsize</a></li><li data-type='method'><a href="LifoQueue.html#put">put</a></li><li data-type='method'><a href="LifoQueue.html#putNoWait">putNoWait</a></li><li data-type='method'><a href="LifoQueue.html#qsize">qsize</a></li><li data-type='method'><a href="LifoQueue.html#taskDone">taskDone</a></li></ul></li><li><a href="Lock.html">Lock</a><ul class='methods'><li data-type='method'><a href="Lock.html#acquire">acquire</a></li><li data-type='method'><a href="Lock.html#locked">locked</a></li><li data-type='method'><a href="Lock.html#release">release</a></li></ul></li><li><a href="PriorityQueue.html">PriorityQueue</a><ul class='methods'><li data-type='method'><a href="PriorityQueue.html#_get">_get</a></li><li data-type='method'><a href="PriorityQueue.html#_put">_put</a></li><li data-type='method'><a href="PriorityQueue.html#empty">empty</a></li><li data-type='method'><a href="PriorityQueue.html#full">full</a></li><li data-type='method'><a href="PriorityQueue.html#get">get</a></li><li data-type='method'><a href="PriorityQueue.html#getNoWait">getNoWait</a></li><li data-type='method'><a href="PriorityQueue.html#join">join</a></li><li data-type='method'><a href="PriorityQueue.html#maxsize">maxsize</a></li><li data-type='method'><a href="PriorityQueue.html#put">put</a></li><li data-type='method'><a href="PriorityQueue.html#putNoWait">putNoWait</a></li><li data-type='method'><a href="PriorityQueue.html#qsize">qsize</a></li><li data-type='method'><a href="PriorityQueue.html#taskDone">taskDone</a></li></ul></li><li><a href="Queue.html">Queue</a><ul class='methods'><li data-type='method'><a href="Queue.html#_get">_get</a></li><li data-type='method'><a href="Queue.html#_put">_put</a></li><li data-type='method'><a href="Queue.html#empty">empty</a></li><li data-type='method'><a href="Queue.html#full">full</a></li><li data-type='method'><a href="Queue.html#get">get</a></li><li data-type='method'><a href="Queue.html#getNoWait">getNoWait</a></li><li data-type='method'><a href="Queue.html#join">join</a></li><li data-type='method'><a href="Queue.html#maxsize">maxsize</a></li><li data-type='method'><a href="Queue.html#put">put</a></li><li data-type='method'><a href="Queue.html#putNoWait">putNoWait</a></li><li data-type='method'><a href="Queue.html#qsize">qsize</a></li><li data-type='method'><a href="Queue.html#taskDone">taskDone</a></li></ul></li><li><a href="QueueEmpty.html">QueueEmpty</a></li><li><a href="QueueFull.html">QueueFull</a></li><li><a href="RateLimiter.html">RateLimiter</a><ul class='methods'><li data-type='method'><a href="RateLimiter.html#.singleton">singleton</a></li><li data-type='method'><a href="RateLimiter.html#getState">getState</a></li><li data-type='method'><a href="RateLimiter.html#reset">reset</a></li><li data-type='method'><a href="RateLimiter.html#setState">setState</a></li><li data-type='method'><a href="RateLimiter.html#wait">wait</a></li></ul></li><li><a href="RateLimiterGroup.html">RateLimiterGroup</a><ul class='methods'><li data-type='method'><a href="RateLimiterGroup.html#add">add</a></li><li data-type='method'><a href="RateLimiterGroup.html#wait">wait</a></li></ul></li><li><a href="Semaphore.html">Semaphore</a><ul class='methods'><li data-type='method'><a href="Semaphore.html#acquire">acquire</a></li><li data-type='method'><a href="Semaphore.html#locked">locked</a></li><li data-type='method'><a href="Semaphore.html#release">release</a></li></ul></li><li><a href="UnorderedWorkQueue.html">UnorderedWorkQueue</a><ul class='methods'><li data-type='method'><a href="UnorderedWorkQueue.html#asCompleted">asCompleted</a></li><li data-type='method'><a href="UnorderedWorkQueue.html#fulfilled">fulfilled</a></li><li data-type='method'><a href="UnorderedWorkQueue.html#get">get</a></li><li data-type='method'><a href="UnorderedWorkQueue.html#pending">pending</a></li><li data-type='method'><a href="UnorderedWorkQueue.html#put">put</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-Array.html">Array</a></li><li><a href="external-Error.html">Error</a></li><li><a href="external-Promise.html">Promise</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">locks.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint no-unsafe-finally: "off" */

import {Future} from './futures.js';


/**
 * A classic multitasking Condition mechanism.
 *
 * @param {Lock} [lock] - A shared lock object that is used to synchronize multiple Conditions.
 * @borrows {Lock.acquire} as foo
 * @borrows Lock.release as bar
 *
 * @example
 * const cond = new Condition();
 * await cond.acquire();
 * setTimeout(() => cond.notify(), 1000);
 * await cond.wait(); // will wait for 1000ms
 * // do work...
 * cond.release();
 * @see Python's [asyncio.Condition]{@link https://docs.python.org/3/library/asyncio-sync.html#condition}
 */
export class Condition {

    constructor(lock) {
        if (lock === undefined) {
            lock = new Lock();
        }
        this._lock = lock;
        this.release = lock.release.bind(lock);
        this._waiters = [];
    }

    /**
     * The internal lock state.
     *
     * @see [Lock.locked]{@link Lock#locked}
     *
     * @returns {boolean}
     */
    locked() {
        return this.lock.locked();
    }

    /**
     * Acquire the internal lock.
     *
     * @see [Lock.acquire]{@link Lock#acquire}
     */
    async acquire() {
        return await this.lock.acquire();
    }

    /**
     * Release the internal lock.
     *
     * @see [Lock.release]{@link Lock#release}
     */
    release() {
        return this.lock.release();
    }

    /**
     * Wait until the condition is satisfied.  When multiple awaiters exist they will
     * be woken up one at a time if [notify]{@link Condition#notify} is used.  If
     * [notifyAll]{@link Condition#notifyAll} is used then all awaiters will be woken up.
     * Once completed the internal {@link Lock} is reacquired.
     */
    async wait() {
        if (!this.locked()) {
            throw new Error('Lock not acquired');
        }
        this.release();
        try {
            const f = new Future();
            this._waiters.push(f);
            try {
                return await f;
            } finally {
                this._waiters.splice(this._waiters.indexOf(f), 1);
            }
        } finally {
            await this.acquire();
        }
    }

    /**
     * Wake up any awaiters using [wait]{@link Condition#wait}.
     *
     * @param {Number} [n=1] - The number of awaiters to wake up.
     */
    notify(n=1) {
        if (!this.locked()) {
            throw new Error('Lock not acquired');
        }
        let idx = 0;
        for (const f of this._waiters) {
            if (idx >= n) {
                break;
            }
            if (!f.done()) {
                idx++;
                f.setResult(true);
            }
        }
    }

    /**
     * Wake up ALL awaiters using [wait]{@link Condition#wait}.
     */
    notifyAll() {
        this.notify(this._waiters.length);
    }
}


/**
 * A classic multitasking lock mechanism.
 *
 * @see Python's [asyncio.Lock]{@link https://docs.python.org/3/library/asyncio-sync.html#lock}
 */
export class Lock {
    constructor() {
        this._waiters = [];
        this._locked = false;
    }

    /**
     * Indicates the internal locked state of the Lock.
     *
     * @returns {boolean}
     */
    locked() {
        return this._locked;
    }

    /**
     * Acquire the lock if available, otherwise wait until it is released
     * and then take the lock and return.
     */
    async acquire() {
        if (!this._locked) {
            this._locked = true;
            return true;
        }
        const f = new Future();
        this._waiters.push(f);
        try {
            await f;
            this._locked = true;
            return true;
        } finally {
            this._waiters.splice(this._waiters.indexOf(f), 1);
        }
    }

    /**
     * Release this lock and wake up and calls to [acquire]{@link Lock#acquire}.
     */
    release() {
        if (!this._locked) {
            throw new Error('Lock is not acquired');
        }
        this._locked = false;
        for (const f of this._waiters) {
            if (!f.done()) {
                f.setResult(true);
                break;
            }
        }
    }
}


/**
 * A classic counting Semaphore used to regulate access to a resource.
 *
 * @param {Number} [value=1] - The number of simultaneous acquisitions
 *                             this semaphore will permit before blocking.
 * @see Python's [asyncio.Semaphore]{@link https://docs.python.org/3/library/asyncio-sync.html#semaphore}
 */
export class Semaphore {
    constructor(value=1) {
        if (value &lt; 0) {
            throw new Error('Value must be >= 0');
        }
        this._value = value;
        this._waiters = [];
    }

    _wakeUpNext() {
        while (this._waiters.length) {
            const waiter = this._waiters.shift();
            if (!waiter.done()) {
                waiter.setResult();
                return;
            }
        }
    }

    /**
     * Has the semaphore exhausted all acquisitions.
     *
     * @returns {boolean} True if it will block an [acquire]{@link Semaphore#acquire}
     */
    locked() {
        return this._value === 0;
    }

    /**
     * Attempt to acquire one of the available slots in this semaphore.
     * If none are available, wait in line until one is available.
     *
     * @returns {boolean} true
     */
    async acquire() {
        while (this._value &lt;= 0) {
            const f = new Future();
            this._waiters.push(f);
            try {
                await f;
            } catch(e) {
                if (this._value > 0) {
                    this._wakeUpNext();
                }
                throw e;
            }
        }
        this._value--;
        return true;
    }

    /**
     * Release a slot previously acquired with [acquire]{@link Semaphore#acquire}
     */
    async release() {
        this._value++;
        this._wakeUpNext();
    }
}


/**
 * A very simple object for indicating when some event has been triggered.
 *
 * @see Python's [asyncio.Event]{@link https://docs.python.org/3/library/asyncio-sync.html#event}
 */
export class Event {
    constructor() {
        this._waiters = [];
        this._isSet = false;
    }

    /**
     * @returns {boolean} True if [set]{@link Event#set} was called.
     */
    isSet() {
        return this._isSet;
    }

    /**
     * Wake ALL awaiters of [wait]{@link Event#wait}
     */
    set() {
        if (!this._isSet) {
            this._isSet = true;
            for (const f of this._waiters) {
                f.setResult(true);
            }
        }
    }

    /**
     * Opposite of [set]{@link Event#set}.  Clear the Event state so future
     * calls to [wait]{@link Event#wait} will block.
     */
    clear() {
        this._isSet = false;
    }

    /**
     * Wait until this event object is triggered with [set]{@link Event#set}.
     *
     * @returns {boolean} true
     */
    async wait() {
        if (this._isSet) {
            return true;
        }
        const f = new Future();
        this._waiters.push(f);
        try {
            return await f;
        } finally {
            this._waiters.splice(this._waiters.indexOf(f), 1);
        }
    }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>

<link type="text/css" rel="stylesheet" href="../../css/jsdoc-overrides.css"/>
<script src="../../js/jsdoc-overrides.js"></script>
